// 2D CST FEM p5.js Simulation with Barrel Aim, CST Assembly, and Stress-Strain Plot
let DOF = 2;
let node_coords = [], elements = [], nodeSprites = [], projectiles = [];
let K_global, F_global;
let carriageX = 250, barrelAngle = 0;
let stressStrainData = [], D;
let gridSlider;

function setup() {
  createCanvas(900, 500);
  gridSlider = createSlider(2, 10, 5, 1);
  gridSlider.position(20, 20);
  setupMaterial();
  buildGrid(gridSlider.value());
}

function setupMaterial() {
  const E = 210e9, nu = 0.3;
  D = [
    [1, nu, 0],
    [nu, 1, 0],
    [0, 0, (1 - nu) / 2]
  ].map(row => row.map(v => v * E / (1 - nu * nu)));
}

function buildGrid(n) {
  node_coords = []; elements = []; nodeSprites = []; stressStrainData = [];
  let cols = n, rows = n;
  let idx = 0;
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      let px = 80 + x * 50, py = 60 + y * 50;
      node_coords.push([px, py]);
      nodeSprites.push({ x: px, y: py, idx: idx++ });
    }
  }
  for (let y = 0; y < rows - 1; y++) {
    for (let x = 0; x < cols - 1; x++) {
      let n1 = y * cols + x, n2 = n1 + 1, n3 = n1 + cols, n4 = n3 + 1;
      elements.push([n1, n2, n3], [n2, n4, n3]);
    }
  }
  let n_nodes = cols * rows;
  K_global = Array(2 * n_nodes).fill().map(_ => Array(2 * n_nodes).fill(0));
  F_global = Array(2 * n_nodes).fill(0);
}

function draw() {
  background(30);
  fill(255); text("Grid: " + gridSlider.value() + "x" + gridSlider.value(), 160, 25);
  if (gridSlider.value() ** 2 !== nodeSprites.length) buildGrid(gridSlider.value());

  fill(200); noStroke(); nodeSprites.forEach(n => ellipse(n.x, n.y, 8));
  drawCarriage();
  updateProjectiles();
  drawMatrix();
  plotStressStrain();
}

function drawCarriage() {
  push();
  translate(carriageX, 420);
  rotate(barrelAngle);
  fill(80); stroke(180);
  rect(0, -5, 60, 10);
  resetMatrix();
  translate(carriageX, 420);
  rect(-40, 0, 80, 20);
  rect(-20, -30, 40, 30);
  pop();
}

function updateProjectiles() {
  projectiles.forEach(p => {
    if (!p.stuck) {
      p.x += p.vx; p.y += p.vy;
      barrelAngle = atan2(p.ty - 420, p.tx - carriageX);
      if (dist(p.x, p.y, p.tx, p.ty) < 5) {
        p.stuck = true;
        p.vx = p.vy = 0;
        assembleNode(p.nIdx);
      }
    }
    fill(p.stuck ? [255, 100, 0] : [255, 200, 0]);
    noStroke();
    ellipse(p.x, p.y, 8);
  });
}

function keyPressed() {
  if (keyCode === LEFT_ARROW) carriageX = max(80, carriageX - 10);
  if (keyCode === RIGHT_ARROW) carriageX = min(width - 80, carriageX + 10);
  if (key === 'e' || key === 'E') exportData();
}

function mousePressed() {
  projectiles = [];
  nodeSprites.forEach(n => {
    let angle = atan2(n.y - 420, n.x - carriageX);
    projectiles.push({ x: carriageX, y: 420, vx: 5 * cos(angle), vy: 5 * sin(angle), tx: n.x, ty: n.y, nIdx: n.idx, stuck: false });
  });
}

function assembleNode(n) {
  elements.forEach((el, ei) => {
    if (el.includes(n)) {
      let I = [];
      el.forEach(nd => I.push(2 * nd, 2 * nd + 1));

      // Dummy nodal displacement vector (for visualization purposes only)
      let u = I.map(i => F_global[i] * 0.001);

      let coords = el.map(i => node_coords[i]);
      let [x1, y1] = coords[0], [x2, y2] = coords[1], [x3, y3] = coords[2];
      let B = getBMatrix(x1, y1, x2, y2, x3, y3);

      let strain = multiplyMatrixVector(B, u);
      let stress = multiplyMatrixVector(D, strain);
      let dispMag = Math.sqrt(u.reduce((acc, val) => acc + val * val, 0));

      stressStrainData.push({ ei, strain, stress, dispMag });

      // Create dummy element stiffness matrix and force vector
      let ke = Array(6).fill().map(_ => Array(6).fill((ei + 1) * 0.1));
      let fe = Array(6).fill((ei + 1) * 1.0);

      for (let i = 0; i < 6; i++) {
        F_global[I[i]] += fe[i];
        for (let j = 0; j < 6; j++) {
          K_global[I[i]][I[j]] += ke[i][j];
        }
      }
      console.log(`Element ${ei} ke:`, ke, `fe:`, fe);
    }
  });
}

function getBMatrix(x1, y1, x2, y2, x3, y3) {
  let A = 0.5 * ((x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1));
  let b = [y2 - y3, y3 - y1, y1 - y2];
  let c = [x3 - x2, x1 - x3, x2 - x1];
  return [
    [b[0], 0, b[1], 0, b[2], 0],
    [0, c[0], 0, c[1], 0, c[2]],
    [c[0], b[0], c[1], b[1], c[2], b[2]]
  ].map(row => row.map(val => val / (2 * A)));
}

function multiplyMatrixVector(mat, vec) {
  return mat.map(row => row.reduce((sum, val, idx) => sum + val * vec[idx], 0));
}

function drawMatrix() {
  const offX = 520, offY = 50, cell = 16;
  fill(255); textSize(10); textAlign(RIGHT, CENTER);
  for (let r = 0; r < 10; r++) for (let c = 0; c < 10; c++)
    text(K_global[r][c].toFixed(1), offX + c * cell, offY + r * cell);
  textAlign(LEFT, CENTER);
  for (let i = 0; i < 10; i++) text(F_global[i].toFixed(1), offX + 10 * cell + 10, offY + i * cell);
}

function plotStressStrain() {
  const x0 = 500, y0 = 420, w = 350, h = 70;
  fill(255); text("Stress & Strain (x10^6 Pa) vs Element", x0, y0 - 10);
  noFill(); stroke(100, 255, 100); beginShape();
  stressStrainData.forEach((d, i) => vertex(x0 + i * 8, y0 - d.stress[0] / 1e6));
  endShape();
  stroke(255, 100, 100); beginShape();
  stressStrainData.forEach((d, i) => vertex(x0 + i * 8, y0 - d.strain[0] * 1e6));
  endShape();
}

function exportData() {
  console.log('K_global:', K_global);
  console.log('F_global:', F_global);
}
